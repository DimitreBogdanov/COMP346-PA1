Q1
i)Explain the reason why a system call must be implemented in the kernel of the operating system (i.e. in system mode).
The reason why system calls need to be implemented in the kernel is because the kernel has access to the hardware
and because the kernel runs in system mode

ii)Some early CPUs (e.g. INTEL 8086) did not implement a mode bit so the operating system
and the user applications execute in the same mode of operation. Explain, if possible,
how the system resources could be protected in such architecture.


Q2
i)Explain how a multitasking OS protects the CPU from faulty running programs?
Multitasking OS protects the cpu by making sure that each running process doesn't hog the entire
processing power. It will give each process a quantum or a time slice during which to execute,
ensuring that all processes are allowed to run, therefor protecting the cpu and other processes
from a single process which would potentially run indefinitely.

ii)Explain a problem that could occur if that CPU protection mechanism is not implemented.
If such a mechanism was not implemented, a running process could go on forever.

Q3
i)Throughput is defined as the amount of work done per unit time. “The degree of multiprogramming in a
computer system has direct influence on the throughput of the system”. Explain with an example.

ii)“Multitasking (i.e. time sharing) is a type of multiprogramming that is useful for interactive systems”. Explain.
Time sharing is useful since it allows the processor resource to be shared by many processes and threads,
alternating between them allowing for multiple tasks to be seemingly executing at the same time.

Q4
i)What is the main difference between user-level threads and kernel-supported threads?
The main difference between user-level threads and kernel-supported threads is that user-level threads created
by a controlling process are not seen by the kernel, it only sees the controlling process, whereas kernel-supported
threads can be seen by the kernel and can be directly processed by it rather than by the controlling process.

ii)For a client application in a client-server system would you use user-level threads or kernel-supported threads?
Explain.
For a client application you would use user-level threads, allowing for a higher level of process control as well
as minimized access to the kernel for regular tasks.

iii)For a server application in a client-server system would you use user-level threads or kernel-supported threads?
Explain.
On a server application on the other hand, you may want to use kernel-supported thread for better optimization and
more control over the running threads and processes.

Q5
i)Explain each step that is performed by the dispatcher during a context switch between two processes.
-While the current process is running on the cpu, an interrupt triggers the context switch.
-Memory and stack state is saved
-Scheduler algorithm runs to determine the next process to be run by the cpu
-The saved memory and stack state of the next process is loaded
-The state for the new process is restored
-Interrupt-return is performed, transferring the execution to the new process

ii)Explain what would be different (if any) if the context switch occurs between two threads of the same controlling process.
The difference in this situation is that the resources are shared between the controlling process and its threads,
meaning that the memory and stack state does not need to be saved and reloaded.

Q6) Suppose that an operating system distinguishes the time that a process or thread is running in user mode and the
time that code is executed in system mode on behalf of that process or thread. Modify the following
process state diagram to reflect the user and system running modes.